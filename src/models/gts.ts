import { model, Schema, Model } from 'mongoose';
import { GtsBlacklist } from './gtsIBlacklist';
/**
 * Interface representing a GTS (Global Trade Station) entry.
 *
 * @interface IGts
 * @extends {Document}
 *
 * @property {string} id - Unique identifier for the GTS entry.
 * @property {string} player_id - Identifier for the player associated with the GTS entry.
 * @property {Object} creature - Details of the creature being traded.
 * @property {string} creature.id - id of the creature.
 * @property {number} creature.level - Level of the creature.
 * @property {boolean} creature.shiny - Indicates if the creature is shiny.
 * @property {number} creature.form - Form of the creature.
 * @property {number} creature.nature - Nature of the creature.
 * @property {Record<string, unknown>} creature.data - Additional data related to the creature.
 * @property {Object} require_conditions - Conditions that Require the trade.
 * @property {string} require_conditions.id - id that are required.
 * @property {Object} require_conditions.level - Level range that is required.
 * @property {number} require_conditions.level.min - Minimum level that is required.
 * @property {number} require_conditions.level.max - Maximum level that is required.
 * @property {boolean} require_conditions.shiny - Indicates if shiny creatures are required.
 * @property {number} require_conditions.form - Form that is required.
 * @property {number} require_conditions.nature - Nature that is required.
 * @property {Date} createdAt - Date when the GTS entry was created.
 */
interface IGts extends Document {
  id: string;
  player_id: string;
  creature: Record<string, unknown>;
  require_conditions: {
    id: string;
    level: { min: number; max?: number };
    shiny?: boolean;
    form?: number;
    nature?: number;
  };
  status: 'deposited' | 'retrieved' | 'traded';
  createdAt: Date;
}

interface IGtsModel extends Model<IGts> {
  /**
   * Adds a creature to the Global Trade Station (GTS) for a player.
   *
   * @param player_id - The ID of the player adding the creature to the GTS.
   * @param creature - The creature to be added to the GTS.
   * @param require_conditions - Conditions under which the creature cannot be traded.
   * @returns An object indicating the success of the operation and an optional message.
   *
   * @remarks
   * This function checks if the creature is blacklisted before adding it to the GTS.
   * If the creature is blacklisted, the function returns a failure message.
   * Otherwise, it saves the new GTS entry and returns a success message.
   */
  addToGTS(
    player_id: string,
    creature: IGts['creature'],
    require_conditions: IGts['require_conditions']
  ): Promise<{ success: boolean; message?: string }>;

  /**
   * Removes a creature from the Global Trade System (GTS) for a given player.
   *
   * @param player_id - The unique identifier of the player.
   * @returns A promise that resolves to an object indicating the success status and an optional message.
   */
  removeFromGTS(
    player_id: string
  ): Promise<{ success: boolean; message?: string }>;

  /**
   * Executes a trade between two players, where player A offers a creature to player B.
   * The trade is subject to certain conditions that must be met by the offered creature.
   *
   * @param playerA_id - The ID of player A who is offering a creature.
   * @param playerB_id - The ID of player B who will receive the offered creature.
   * @param offeredCreature - The creature offered by player A for the trade.
   * @returns A promise that resolves to an object indicating the success of the trade,
   *          an optional message, and the creature received by player B if the trade is successful.
   */
  tradeWithOffer(
    playerA_id: string,
    offeredCreature: IGts['creature']
  ): Promise<{
    success: boolean;
    message?: string;
    receivedCreature?: IGts['creature'];
  }>;

  getPlayerCreatures(
    player_id: string
  ): Promise<{ deposited: IGts[]; traded: IGts[]; retrieved: IGts[] }>;

  getAllCreatures(filters: {
    id?: string;
    level?: {
      min?: number;
      max?: number;
    };
    shiny?: boolean;
    form?: number;
    nature?: number;
  }): Promise<IGts[]>;
}

/**
 * Schema definition for the GTS (Global Trade Station) model.
 *
 * @typedef {Object} IGts
 * @property {string} id - Unique identifier for the GTS entry, generated by default.
 * @property {string} player_id - Identifier for the player, required.
 * @property {Object} creature - Details of the creature being traded.
 * @property {string} creature.id - id of the creature, required.
 * @property {number} creature.level - Level of the creature, required.
 * @property {boolean} creature.shiny - Indicates if the creature is shiny, required.
 * @property {number} creature.form - Form of the creature, required.
 * @property {number} creature.nature - Nature of the creature, required.
 * @property {Schema.Types.Mixed} creature.data - Additional data for the creature, required.
 * @property {Object} require_conditions - Conditions that Require the trade.
 * @property {string} require_conditions.id - required id, required.
 * @property {Object} require_conditions.level - Level conditions for the trade.
 * @property {number} require_conditions.level.min - Minimum level, required.
 * @property {number} require_conditions.level.max - Maximum level, optional.
 * @property {boolean} require_conditions.shiny - Indicates if shiny creatures are required, required.
 * @property {number} require_conditions.form - required form, required.
 * @property {number} require_conditions.nature - required nature, required.
 * @property {Date} createdAt - Timestamp of when the entry was created, defaults to current date.
 */
const SGts = new Schema<IGts>({
  id: {
    type: String,
    default: () => `gts-${Math.random().toString(36).substring(2, 10)}`,
    unique: true,
  },
  player_id: { type: String, required: true },
  creature: {
    type: Map,
    of: Schema.Types.Mixed,
    required: true,
  },
  require_conditions: {
    id: { type: String, required: true },
    level: {
      min: { type: Number, required: true, min: 1 },
      max: { type: Number, max: process.env.MAX_LEVEL },
    },
    shiny: { type: Boolean },
    form: { type: Number },
    nature: { type: Number },
  },
  status: {
    type: String,
    enum: ['deposited', 'retrieved', 'traded'],
    default: 'deposited',
  },
  createdAt: { type: Date, default: Date.now },
});

type CreatureType = {
  id: string;
  level: number;
  shiny: boolean;
  form: number;
  nature: number;
};

SGts.statics.addToGTS = async function (
  player_id: string,
  creature: CreatureType,
  require_conditions: IGts['require_conditions']
): Promise<{ success: boolean; message?: string }> {
  try {
    const blacklistCheck = await GtsBlacklist.isBlacklisted({
      id: creature.id,
      level: creature.level,
      shiny: creature.shiny,
      form: creature.form,
      nature: creature.nature,
    });

    if (!blacklistCheck.success) {
      return {
        success: false,
        message: `Creature rejected: ${blacklistCheck.message}`,
      };
    }

    const alreadyDeposited = await this.exists({
      player_id,
      status: 'deposited',
    });
    if (alreadyDeposited) {
      return {
        success: false,
        message: 'You already have a creature on deposit on the GTS.',
      };
    }

    await this.create({ player_id, creature, require_conditions });

    return { success: true, message: 'Creature successfully added to GTS' };
  } catch (error) {
    console.error('Error adding creature to GTS:', error);
    return {
      success: false,
      message: 'An unexpected error occurred. Please try again later.',
    };
  }
};

SGts.statics.removeFromGTS = async function (
  player_id?: string,
  id?: string
): Promise<{ success: boolean; message?: string }> {
  try {
    const gtsEntry = await this.findOne({
      ...(player_id ? { player_id } : { id }),
      status: 'deposited',
    });

    if (!gtsEntry) {
      return {
        success: false,
        message: 'No deposited creature found for this player.',
      };
    }

    await this.updateOne({ player_id }, { status: 'retrieved' });

    return { success: true, message: 'Creature successfully removed from GTS' };
  } catch (error) {
    console.error('Error removing creature from GTS:', error);
    return {
      success: false,
      message: 'An unexpected error occurred. Please try again later.',
    };
  }
};

SGts.statics.tradeWithOffer = async function (
  playerA_id: string,
  offeredCreature: CreatureType
): Promise<{
  success: boolean;
  message?: string;
  receivedCreature?: IGts['creature'];
}> {
  try {
    const entryA = await this.findOne({
      player_id: playerA_id,
      status: 'deposited',
    });

    if (!entryA) {
      return {
        success: false,
        message: 'No valid deposited creature found for player A.',
      };
    }

    const conditions = entryA.require_conditions;
    if (
      (conditions.id &&
        conditions.id !== offeredCreature.id) ||
      (conditions.level &&
        (offeredCreature.level < conditions.level.min ||
          (conditions.level.max &&
            offeredCreature.level > conditions.level.max))) ||
      (conditions.shiny !== undefined &&
        conditions.shiny !== offeredCreature.shiny) ||
      (conditions.form !== undefined &&
        conditions.form !== offeredCreature.form) ||
      (conditions.nature !== undefined &&
        conditions.nature !== offeredCreature.nature)
    ) {
      return {
        success: false,
        message: 'The offered creature does not meet the trade conditions.',
      };
    }

    const creatureForB = entryA.creature;

    await this.updateOne(
      { player_id: playerA_id },
      { creature: offeredCreature, status: 'traded' }
    );

    return {
      success: true,
      message: 'Trade successfully completed!',
      receivedCreature: creatureForB,
    };
  } catch (error) {
    console.error('Error during trade:', error);
    return {
      success: false,
      message: 'An unexpected error occurred. Please try again later.',
    };
  }
};

SGts.statics.getPlayerCreatures = async function (
  player_id: string
): Promise<{ deposited: IGts[]; traded: IGts[]; retrieved: IGts[] }> {
  try {
    const [deposited, traded, retrieved] = await Promise.all([
      this.find({ player_id, status: 'deposited' }),
      this.find({ player_id, status: 'traded' }),
      this.find({ player_id, status: 'retrieved' }),
    ]);

    return { deposited, traded, retrieved };
  } catch (error) {
    console.error('Error fetching player creatures:', error);
    throw new Error(
      'An unexpected error occurred while retrieving player creatures.'
    );
  }
};

SGts.statics.getAllCreatures = async function (filters: {
  id?: string;
  level?: {
    min?: number;
    max?: number;
  };
  shiny?: boolean;
  form?: number;
  nature?: number;
}): Promise<IGts[]> {
  try {
    const query: Record<string, unknown> = {};

    if (filters.id) query['creature.id'] = filters.id;
    if (filters.level) {
      query['creature.level'] = {};
      if (filters.level.min) {
        if (!query['creature.level']) query['creature.level'] = {};
        (query['creature.level'] as { $gte?: number; $lte?: number }).$gte =
          filters.level.min;
      }
      if (filters.level.max) {
        if (!query['creature.level']) query['creature.level'] = {};
        (query['creature.level'] as { $gte?: number; $lte?: number }).$lte =
          filters.level.max;
      }
    }
    if (filters.shiny !== undefined) query['creature.shiny'] = filters.shiny;
    if (filters.form !== undefined) query['creature.form'] = filters.form;
    if (filters.nature !== undefined) query['creature.nature'] = filters.nature;
    query['status'] = 'deposited';

    return await this.find(query).select({
      id: 1,
      player_id: 1,
      'creature.id': 1,
      'creature.level': 1,
      'creature.shiny': 1,
      'creature.form': 1,
      'creature.nature': 1,
    });
  } catch (error) {
    console.error('Error fetching filtered creatures:', error);
    throw new Error('An unexpected error occurred while retrieving creatures.');
  }
};

/**
 * Represents the Gts model.
 *
 * This model is created using the `model` function from the Mongoose library.
 * It uses the `IGts` interface for the document shape and the `IGtsModel` interface for the model's static methods.
 * The schema used for this model is `SGts`.
 *
 * @type {Model<IGts, IGtsModel>}
 */
const Gts = model<IGts, IGtsModel>('Gts', SGts);

export { Gts, IGts };
