import { Schema } from 'mongoose';
import { GtsBlacklist } from './gtsIBlacklist';
import { ICreature } from './creature.model';
import { IGts } from './gts.model';

/**
 * Schema definition for the GTS (Global Trade Station) model.
 *
 * @typedef {Object} IGts
 * @property {string} id - Unique identifier for the GTS entry, generated by default.
 * @property {string} player_id - Identifier for the player, required.
 * @property {Object} creature - Details of the creature being traded.
 * @property {string} creature.id - id of the creature, required.
 * @property {number} creature.level - Level of the creature, required.
 * @property {boolean} creature.shiny - Indicates if the creature is shiny, required.
 * @property {number} creature.form - Form of the creature, required.
 * @property {number} creature.nature - Nature of the creature, required.
 * @property {Schema.Types.Mixed} creature.data - Additional data for the creature, required.
 * @property {Object} require_conditions - Conditions that Require the trade.
 * @property {string} require_conditions.id - required id, required.
 * @property {Object} require_conditions.level - Level conditions for the trade.
 * @property {number} require_conditions.level.min - Minimum level, required.
 * @property {number} require_conditions.level.max - Maximum level, optional.
 * @property {boolean} require_conditions.shiny - Indicates if shiny creatures are required, required.
 * @property {number} require_conditions.form - required form, required.
 * @property {number} require_conditions.nature - required nature, required.
 * @property {Date} createdAt - Timestamp of when the entry was created, defaults to current date.
 */
export const SGts = new Schema<IGts>({
  id: {
    type: String,
    default: () => `gts-${Math.random().toString(36).substring(2, 10)}`,
    unique: true,
  },
  player_id: { type: String, required: true },
  creature: {
    type: Map,
    of: Schema.Types.Mixed,
    required: true,
  },
  require_conditions: {
    id: { type: String, required: true },
    level: {
      min: { type: Number, required: true, min: 1 },
      max: { type: Number, max: process.env.MAX_LEVEL },
    },
    shiny: { type: Boolean },
    form: { type: Number },
    nature: { type: Number },
  },
  status: {
    type: String,
    enum: ['deposited', 'retrieved', 'traded'],
    default: 'deposited',
  },
  createdAt: { type: Date, default: Date.now },
});

SGts.statics.addToGTS = async function (
  player_id: string,
  creature: ICreature,
  require_conditions: IGts['require_conditions']
): Promise<{ success: boolean; message?: string }> {
  try {
    const blacklistCheck = await GtsBlacklist.isBlacklisted({
      id: creature.id,
      level: creature.level,
      shiny: creature.shiny,
      form: creature.form,
      nature: creature.nature,
    });

    if (!blacklistCheck.success) {
      return {
        success: false,
        message: `Creature rejected: ${blacklistCheck.message}`,
      };
    }

    const alreadyDeposited = await this.exists({
      player_id,
      status: 'deposited',
    });
    if (alreadyDeposited) {
      return {
        success: false,
        message: 'You already have a creature on deposit on the GTS.',
      };
    }

    await this.create({ player_id, creature, require_conditions });

    return { success: true, message: 'Creature successfully added to GTS' };
  } catch (error) {
    console.error('Error adding creature to GTS:', error);
    return {
      success: false,
      message: 'An unexpected error occurred. Please try again later.',
    };
  }
};

SGts.statics.removeFromGTS = async function (
  player_id?: string,
  id?: string
): Promise<{ success: boolean; message?: string }> {
  try {
    const gtsEntry = await this.findOne({
      ...(player_id ? { player_id } : { id }),
      status: 'deposited',
    });

    if (!gtsEntry) {
      return {
        success: false,
        message: 'No deposited creature found for this player.',
      };
    }

    await this.updateOne({ player_id }, { status: 'retrieved' });

    return { success: true, message: 'Creature successfully removed from GTS' };
  } catch (error) {
    console.error('Error removing creature from GTS:', error);
    return {
      success: false,
      message: 'An unexpected error occurred. Please try again later.',
    };
  }
};

SGts.statics.tradeWithOffer = async function (
  playerA_id: string,
  offeredCreature: ICreature
): Promise<{
  success: boolean;
  message?: string;
  receivedCreature?: IGts['creature'];
}> {
  try {
    const entryA = await this.findOne({
      player_id: playerA_id,
      status: 'deposited',
    });

    if (!entryA) {
      return {
        success: false,
        message: 'No valid deposited creature found for player A.',
      };
    }

    const conditions = entryA.require_conditions;
    if (
      (conditions.id &&
        conditions.id !== offeredCreature.id) ||
      (conditions.level &&
        (offeredCreature.level < conditions.level.min ||
          (conditions.level.max &&
            offeredCreature.level > conditions.level.max))) ||
      (conditions.shiny !== undefined &&
        conditions.shiny !== offeredCreature.shiny) ||
      (conditions.form !== undefined &&
        conditions.form !== offeredCreature.form) ||
      (conditions.nature !== undefined &&
        conditions.nature !== offeredCreature.nature)
    ) {
      return {
        success: false,
        message: 'The offered creature does not meet the trade conditions.',
      };
    }

    const creatureForB = entryA.creature;

    await this.updateOne(
      { player_id: playerA_id },
      { creature: offeredCreature, status: 'traded' }
    );

    return {
      success: true,
      message: 'Trade successfully completed!',
      receivedCreature: creatureForB,
    };
  } catch (error) {
    console.error('Error during trade:', error);
    return {
      success: false,
      message: 'An unexpected error occurred. Please try again later.',
    };
  }
};

SGts.statics.getPlayerCreatures = async function (
  player_id: string
): Promise<{ deposited: IGts[]; traded: IGts[]; retrieved: IGts[] }> {
  try {
    const [deposited, traded, retrieved] = await Promise.all([
      this.find({ player_id, status: 'deposited' }),
      this.find({ player_id, status: 'traded' }),
      this.find({ player_id, status: 'retrieved' }),
    ]);

    return { deposited, traded, retrieved };
  } catch (error) {
    console.error('Error fetching player creatures:', error);
    throw new Error(
      'An unexpected error occurred while retrieving player creatures.'
    );
  }
};

SGts.statics.getAllCreatures = async function (filters: {
  id?: string;
  level?: {
    min?: number;
    max?: number;
  };
  shiny?: boolean;
  form?: number;
  nature?: number;
}): Promise<IGts[]> {
  try {
    const query: Record<string, unknown> = {};

    if (filters.id) query['creature.id'] = filters.id;
    if (filters.level) {
      query['creature.level'] = {};
      if (filters.level.min) {
        if (!query['creature.level']) query['creature.level'] = {};
        (query['creature.level'] as { $gte?: number; $lte?: number }).$gte =
          filters.level.min;
      }
      if (filters.level.max) {
        if (!query['creature.level']) query['creature.level'] = {};
        (query['creature.level'] as { $gte?: number; $lte?: number }).$lte =
          filters.level.max;
      }
    }
    if (filters.shiny !== undefined) query['creature.shiny'] = filters.shiny;
    if (filters.form !== undefined) query['creature.form'] = filters.form;
    if (filters.nature !== undefined) query['creature.nature'] = filters.nature;
    query['status'] = 'deposited';

    return await this.find(query).select({
      id: 1,
      player_id: 1,
      'creature.id': 1,
      'creature.level': 1,
      'creature.shiny': 1,
      'creature.form': 1,
      'creature.nature': 1,
    });
  } catch (error) {
    console.error('Error fetching filtered creatures:', error);
    throw new Error('An unexpected error occurred while retrieving creatures.');
  }
};

